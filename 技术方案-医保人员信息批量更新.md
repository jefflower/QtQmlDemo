# 医保人员信息批量更新工具 - 技术实施方案

## 1. 需求概述

开发一个基于Qt/QML的医保人员信息批量更新工具，主要功能：
- 连接MySQL数据库查询就诊记录
- 调用医保接口获取人员身份信息
- 批量更新就诊记录的社保分组代码
- 提供友好的进度和日志界面

## 2. 技术架构

### 2.1 技术栈
- **前端**: Qt Quick/QML 2.15
- **后端**: C++ (Qt 5.15)
- **数据库**: MySQL (通过Qt SQL模块)
- **网络**: Qt Network (QNetworkAccessManager)
- **JSON处理**: Qt JSON模块

### 2.2 核心组件

```
MedicalDataProcessor (C++后端)
├── DatabaseManager - 数据库连接和查询
├── HttpClient - HTTP接口调用
├── DataProcessor - 业务逻辑处理
└── Logger - 日志管理

ProcessPage.qml (QML界面)
├── 时间范围输入区
├── 控制按钮区
├── 进度显示区
└── 日志滚动区
```

## 3. 详细设计

### 3.1 数据库设计

**数据库连接配置**:
- Host: 220.195.4.143
- Port: 33306
- Database: microhis_hsd
- Username: root
- Password: his@2024

**查询SQL**:
```sql
SELECT t_visit.Visit_ID,
       t_visit.Patient_Name,
       hip_mpi.decrypt_data(t_visit_extra.IDCert_No) as IDCert_No,
       t_visit.SS_Group_Code
FROM microhis_hsd.t_visit
INNER JOIN microhis_hsd.t_visit_extra ON t_visit.Visit_ID = t_visit_extra.Visit_ID
WHERE Time_Admission >= ? AND Time_Admission < ?
```

**更新SQL**:
```sql
UPDATE microhis_hsd.t_visit
SET SS_Group_Code = ?
WHERE Visit_ID = ?
```

### 3.2 接口调用设计

**接口地址**: `http://127.0.0.1:5000/api/mi/GetPersonInfo`

**请求体模板**:
```json
{
  "card_info": {
    "mdtrt_cert_type": "02",
    "mdtrt_cert_no": "${IDCert_No}",
    "psn_cert_type": "01",
    "certno": "${IDCert_No}",
    "psn_cert_no": "${IDCert_No}",
    "card_sn": null,
    "psn_name": "",
    "age": "46",
    "birthday": 19790125,
    "gender": "1",
    "nation": null,
    "address": null,
    "insuplc_admdvs": null,
    "read_time": "当前时间",
    "extra_props": null
  },
  "business_type_id": "104",
  "medical_type": 11,
  "mdtrt_cert_type": "01",
  "psn_name": "",
  "psn_cert_no": "${IDCert_No}",
  "mdtrt_cert_no": "${IDCert_No}",
  "card_sn": "",
  "insuplc_admdvs": "",
  "opter": 0,
  "org_id": 130624002,
  "user_id": 0
}
```

**响应解析规则**:
1. 检查 `code == 0`
2. 提取 `data.idetinfo` 数组
3. 如果数组非空，取最后一条的 `psn_idet_type`
4. 异常情况（code != 0 或 idetinfo为空）设置为 NULL

### 3.3 业务流程

```
用户输入时间范围 (起始时间, 结束时间)
    ↓
点击"开始执行"按钮
    ↓
按天拆分时间范围 [Day1, Day2, ..., DayN]
    ↓
FOR EACH 天 in 时间范围:
    ├─ 显示进度: "正在修正 YYYY-MM-DD 的数据"
    ├─ 执行SQL查询该天的就诊记录
    ├─ FOR EACH 记录 in 查询结果:
    │   ├─ 显示日志: "正在处理 {姓名} {身份证号}"
    │   ├─ 调用医保接口 GetPersonInfo
    │   ├─ 等待响应
    │   ├─ 解析响应获取 psn_idet_type
    │   ├─ 显示日志: "查询结果为 {psn_idet_type} {memo}"
    │   ├─ 显示日志: "更新visit数据"
    │   ├─ 执行UPDATE SQL
    │   └─ 处理下一条
    └─ 处理下一天
    ↓
全部完成，显示汇总统计
```

### 3.4 C++ 类设计

#### 3.4.1 MedicalDataProcessor (主处理类)

```cpp
class MedicalDataProcessor : public QObject {
    Q_OBJECT
    Q_PROPERTY(QString progressText READ progressText NOTIFY progressTextChanged)
    Q_PROPERTY(QString logText READ logText NOTIFY logTextChanged)
    Q_PROPERTY(bool isProcessing READ isProcessing NOTIFY isProcessingChanged)
    Q_PROPERTY(int totalDays READ totalDays NOTIFY totalDaysChanged)
    Q_PROPERTY(int currentDay READ currentDay NOTIFY currentDayChanged)
    Q_PROPERTY(int totalRecords READ totalRecords NOTIFY totalRecordsChanged)
    Q_PROPERTY(int processedRecords READ processedRecords NOTIFY processedRecordsChanged)
    Q_PROPERTY(int successCount READ successCount NOTIFY successCountChanged)
    Q_PROPERTY(int failCount READ failCount NOTIFY failCountChanged)

public:
    Q_INVOKABLE void startProcess(const QString &startTime, const QString &endTime);
    Q_INVOKABLE void stopProcess();
    Q_INVOKABLE bool testDatabaseConnection();

signals:
    void progressTextChanged();
    void logTextChanged();
    void isProcessingChanged();
    void processCompleted();
    void errorOccurred(const QString &error);
    // ... 其他信号

private slots:
    void processNextDay();
    void processNextRecord();
    void onHttpResponse(const QJsonObject &response);

private:
    DatabaseManager *m_dbManager;
    HttpClient *m_httpClient;
    QStringList m_daysList;
    QList<VisitRecord> m_currentDayRecords;
    int m_currentDayIndex;
    int m_currentRecordIndex;
    // ... 统计变量
};
```

#### 3.4.2 DatabaseManager (数据库管理)

```cpp
class DatabaseManager : public QObject {
    Q_OBJECT

public:
    bool connectToDatabase();
    QList<VisitRecord> queryVisitsByDate(const QDate &date);
    bool updateVisitSSGroupCode(int visitId, const QString &groupCode);
    void closeConnection();

private:
    QSqlDatabase m_db;
    QString m_connectionName;
};
```

#### 3.4.3 HttpClient (HTTP客户端)

```cpp
class HttpClient : public QObject {
    Q_OBJECT

public:
    void getPersonInfo(const QString &idCertNo);

signals:
    void responseReceived(const QJsonObject &response);
    void requestFailed(const QString &error);

private:
    QNetworkAccessManager *m_manager;
    QString m_apiUrl;
};
```

#### 3.4.4 数据结构

```cpp
struct VisitRecord {
    int visitId;
    QString patientName;
    QString idCertNo;
    QString ssGroupCode;
};

struct IdetInfo {
    QString psnIdetType;
    QString memo;
    QString begntime;
    QString endtime;
};
```

### 3.5 QML界面设计

#### ProcessPage.qml 布局

```qml
Page {
    ColumnLayout {
        // 1. 数据库连接状态区
        RowLayout {
            Label { text: "数据库连接:" }
            Rectangle {
                color: processor.dbConnected ? "green" : "red"
                width: 16; height: 16; radius: 8
            }
            Button {
                text: "测试连接"
                onClicked: processor.testDatabaseConnection()
            }
        }

        // 2. 时间范围输入区
        GroupBox {
            title: "时间范围设置"
            GridLayout {
                Label { text: "开始时间:" }
                TextField {
                    id: startTimeInput
                    placeholderText: "2025-01-01 00:00:00"
                }

                Label { text: "结束时间:" }
                TextField {
                    id: endTimeInput
                    placeholderText: "2025-01-31 23:59:59"
                }
            }
        }

        // 3. 控制按钮区
        RowLayout {
            Button {
                text: processor.isProcessing ? "停止执行" : "开始执行"
                enabled: !processor.isProcessing || processor.canStop
                onClicked: {
                    if (processor.isProcessing) {
                        processor.stopProcess()
                    } else {
                        processor.startProcess(
                            startTimeInput.text,
                            endTimeInput.text
                        )
                    }
                }
            }
        }

        // 4. 进度显示区
        GroupBox {
            title: "执行进度"
            ColumnLayout {
                ProgressBar {
                    value: processor.totalDays > 0
                           ? processor.currentDay / processor.totalDays
                           : 0
                    Layout.fillWidth: true
                }

                Label {
                    text: processor.progressText
                    font.bold: true
                }

                GridLayout {
                    columns: 4
                    Label { text: "总天数: " + processor.totalDays }
                    Label { text: "当前: " + processor.currentDay }
                    Label { text: "总记录: " + processor.totalRecords }
                    Label { text: "已处理: " + processor.processedRecords }
                    Label { text: "成功: " + processor.successCount; color: "green" }
                    Label { text: "失败: " + processor.failCount; color: "red" }
                }
            }
        }

        // 5. 日志显示区
        GroupBox {
            title: "执行日志"
            Layout.fillHeight: true

            ScrollView {
                anchors.fill: parent

                TextArea {
                    id: logArea
                    text: processor.logText
                    readOnly: true
                    wrapMode: TextEdit.Wrap
                    font.family: "Consolas"
                    font.pixelSize: 12

                    // 自动滚动到底部
                    onTextChanged: {
                        cursorPosition = length - 1
                    }
                }
            }
        }
    }
}
```

### 3.6 关键实现细节

#### 3.6.1 按天拆分时间范围

```cpp
QStringList MedicalDataProcessor::splitDateRange(
    const QString &startTime, const QString &endTime) {

    QStringList days;
    QDateTime start = QDateTime::fromString(startTime, "yyyy-MM-dd hh:mm:ss");
    QDateTime end = QDateTime::fromString(endTime, "yyyy-MM-dd hh:mm:ss");

    QDate currentDate = start.date();
    QDate endDate = end.date();

    while (currentDate <= endDate) {
        days.append(currentDate.toString("yyyy-MM-dd"));
        currentDate = currentDate.addDays(1);
    }

    return days;
}
```

#### 3.6.2 异步处理机制

使用 **状态机模式** + **事件驱动**:
1. 不使用阻塞循环
2. 每处理完一条记录，通过信号槽触发下一条
3. HTTP请求完成后才处理下一个
4. 确保UI响应流畅

```cpp
void MedicalDataProcessor::processNextRecord() {
    if (m_currentRecordIndex >= m_currentDayRecords.size()) {
        // 当天处理完成，进入下一天
        processNextDay();
        return;
    }

    VisitRecord record = m_currentDayRecords[m_currentRecordIndex];

    // 添加日志
    appendLog(QString("正在处理 %1 %2")
        .arg(record.patientName)
        .arg(record.idCertNo));

    // 发起HTTP请求（异步）
    m_httpClient->getPersonInfo(record.idCertNo);

    // 等待 onHttpResponse 回调
}

void MedicalDataProcessor::onHttpResponse(const QJsonObject &response) {
    VisitRecord record = m_currentDayRecords[m_currentRecordIndex];

    // 解析响应
    QString psnIdetType;
    QString memo;

    if (response["code"].toInt() == 0) {
        QJsonArray idetinfo = response["data"].toObject()["idetinfo"].toArray();
        if (!idetinfo.isEmpty()) {
            QJsonObject lastItem = idetinfo.last().toObject();
            psnIdetType = lastItem["psn_idet_type"].toString();
            memo = lastItem["memo"].toString();
        }
    }

    // 添加日志
    if (!psnIdetType.isEmpty()) {
        appendLog(QString("查询结果为 %1 %2").arg(psnIdetType).arg(memo));
    } else {
        appendLog("查询结果为空，设置为NULL");
    }

    // 更新数据库
    appendLog("更新visit数据");
    bool success = m_dbManager->updateVisitSSGroupCode(
        record.visitId, psnIdetType.isEmpty() ? QString() : psnIdetType);

    if (success) {
        m_successCount++;
    } else {
        m_failCount++;
    }

    m_processedRecords++;
    m_currentRecordIndex++;

    emit processedRecordsChanged();
    emit successCountChanged();

    // 处理下一条（通过QTimer延迟，避免界面卡顿）
    QTimer::singleShot(100, this, &MedicalDataProcessor::processNextRecord);
}
```

#### 3.6.3 日志追加实现

```cpp
void MedicalDataProcessor::appendLog(const QString &message) {
    QString timestamp = QDateTime::currentDateTime().toString("hh:mm:ss");
    QString logLine = QString("[%1] %2\n").arg(timestamp).arg(message);

    m_logText += logLine;
    emit logTextChanged();

    // 可选：同时输出到控制台
    qDebug() << message;
}
```

#### 3.6.4 错误处理策略

```cpp
// HTTP请求失败
void MedicalDataProcessor::onHttpError(const QString &error) {
    appendLog(QString("接口调用失败: %1").arg(error));

    // 设置为NULL并继续
    VisitRecord record = m_currentDayRecords[m_currentRecordIndex];
    m_dbManager->updateVisitSSGroupCode(record.visitId, QString());

    m_failCount++;
    m_processedRecords++;
    m_currentRecordIndex++;

    // 继续下一条
    QTimer::singleShot(100, this, &MedicalDataProcessor::processNextRecord);
}

// 数据库错误
void MedicalDataProcessor::onDatabaseError(const QString &error) {
    appendLog(QString("数据库错误: %1").arg(error));
    emit errorOccurred(error);

    // 可选择终止或继续
    if (m_stopOnError) {
        stopProcess();
    }
}
```

## 4. 项目文件结构

```
QtQmlDemo/
├── src/
│   ├── main.cpp
│   ├── backend.h/cpp (已有)
│   ├── medicaldataprocessor.h/cpp (新增)
│   ├── databasemanager.h/cpp (新增)
│   └── httpclient.h/cpp (新增)
├── qml/
│   ├── Main.qml (修改，添加新页面)
│   ├── HomePage.qml (已有)
│   ├── SettingsPage.qml (已有)
│   └── ProcessPage.qml (新增)
├── CMakeLists.txt (修改，添加Qt SQL和Network模块)
└── qml.qrc (修改，添加新QML文件)
```

## 5. CMakeLists.txt 修改

```cmake
# 添加Qt SQL和Network模块
find_package(Qt5 5.12 REQUIRED COMPONENTS
    Core Quick Qml Widgets
    Sql Network)  # 新增

# 添加新的源文件
add_executable(QtQmlDemo
    src/main.cpp
    src/backend.cpp
    src/backend.h
    src/medicaldataprocessor.cpp      # 新增
    src/medicaldataprocessor.h        # 新增
    src/databasemanager.cpp           # 新增
    src/databasemanager.h             # 新增
    src/httpclient.cpp                # 新增
    src/httpclient.h                  # 新增
    qml.qrc
)

# 链接新模块
target_link_libraries(QtQmlDemo
    Qt5::Core
    Qt5::Quick
    Qt5::Qml
    Qt5::QuickControls2
    Qt5::Widgets
    Qt5::Sql          # 新增
    Qt5::Network      # 新增
)
```

## 6. 实现步骤

### 阶段一：基础框架搭建 (1-2小时)
1. ✅ 创建 DatabaseManager 类
2. ✅ 创建 HttpClient 类
3. ✅ 创建 MedicalDataProcessor 类框架
4. ✅ 创建 ProcessPage.qml 基础界面
5. ✅ 更新 Main.qml 添加新页面导航

### 阶段二：数据库功能实现 (1小时)
1. ✅ 实现数据库连接
2. ✅ 实现查询功能（按天查询）
3. ✅ 实现更新功能
4. ✅ 添加数据库连接测试功能

### 阶段三：HTTP接口实现 (1小时)
1. ✅ 实现HTTP POST请求
2. ✅ 实现JSON请求体构建
3. ✅ 实现JSON响应解析
4. ✅ 实现错误处理

### 阶段四：业务逻辑实现 (2小时)
1. ✅ 实现时间范围拆分
2. ✅ 实现异步处理流程
3. ✅ 实现进度跟踪
4. ✅ 实现日志记录

### 阶段五：界面完善 (1小时)
1. ✅ 完善进度显示
2. ✅ 完善日志显示
3. ✅ 添加统计信息
4. ✅ 优化交互体验

### 阶段六：测试与优化 (1小时)
1. ✅ 单元测试
2. ✅ 集成测试
3. ✅ 错误场景测试
4. ✅ 性能优化

## 7. 风险与注意事项

### 7.1 性能风险
- **问题**: 大量数据处理可能导致界面卡顿
- **方案**:
  - 每处理一条记录后延迟100ms
  - 使用异步处理，避免阻塞主线程
  - 考虑添加批量处理模式

### 7.2 网络风险
- **问题**: HTTP接口调用失败或超时
- **方案**:
  - 设置合理的超时时间（如30秒）
  - 实现重试机制（可选3次）
  - 失败时设置为NULL并继续

### 7.3 数据库风险
- **问题**: 数据库连接中断或超时
- **方案**:
  - 实现连接保活机制
  - 每天重新检查连接状态
  - 失败时允许重新连接

### 7.4 数据一致性
- **问题**: 处理中断后的恢复
- **方案**:
  - 记录处理进度到本地文件
  - 支持断点续传
  - 提供"跳过已处理"选项

### 7.5 身份证解密函数
- **问题**: `hip_mpi.decrypt_data()` 可能不存在或权限不足
- **方案**:
  - 启动前测试SQL是否能正常执行
  - 提供错误提示和解决建议

## 8. 测试计划

### 8.1 单元测试
- DatabaseManager 数据库连接测试
- HttpClient HTTP请求测试
- 时间范围拆分函数测试
- JSON解析函数测试

### 8.2 集成测试
- 完整流程测试（小数据量：1天，10条记录）
- 边界测试（空数据、单条数据）
- 异常测试（接口返回异常、数据库断连）

### 8.3 压力测试
- 大数据量测试（30天，1000+记录）
- 长时间运行稳定性测试

## 9. 后续优化方向

1. **并发处理**: 支持多线程并发调用接口（需注意数据库连接池）
2. **断点续传**: 处理中断后可从上次位置继续
3. **导出报告**: 处理完成后导出Excel统计报告
4. **配置管理**: 数据库连接、接口地址可配置化
5. **日志持久化**: 日志保存到文件，支持历史查看

## 10. 交付物清单

- [ ] 源代码（C++ + QML）
- [ ] 编译后的可执行程序
- [ ] 用户操作手册
- [ ] 技术文档
- [ ] 测试报告

---

## 确认事项

请确认以下关键点：

1. ✅ 数据库连接信息是否正确？
2. ✅ SQL中的 `hip_mpi.decrypt_data()` 函数是否存在且有权限调用？
3. ✅ HTTP接口地址 `http://127.0.0.1:5000` 是否可访问？
4. ✅ 接口请求体中的固定参数（如org_id: 130624002）是否正确？
5. ✅ 是否需要处理接口调用频率限制（如每秒最多调用X次）？
6. ✅ 更新失败时的处理策略（终止 or 继续）？
7. ✅ 是否需要在界面上添加"暂停/恢复"功能？

**预计开发时间**: 6-8小时
**建议分2-3次迭代完成，每次迭代后进行测试和反馈**
